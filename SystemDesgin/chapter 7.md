## 第7章：在分布式系统中设计唯一的ID生成器 

在本章中，要求您在分布式系统中设计一个唯一的ID生成器。 您的第一个想法可能是在传统数据库中使用Auto_increment属性的主键。 但是，auto_increment在分布式环境中不起作用，因为单个数据库服务器不够大，并且在具有最小延迟的多个数据库中生成唯一的IDS是具有挑战性的.

以下是唯一ID的一些例子:

![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-7/7-1.png)
图 7-1

### 第1步 - 理解问题并建立设计范围
提出澄清问题是解决任何系统设计面试问题的第一步。 这是候选人与采访者互动的一个例子:
候选人：唯一ID的特征是什么？ 
采访者：ID必须是独一无二的和可供选择的。 
候选人：对于每个新记录，id递增1？ 
采访者：id按时间增量但不一定只有1.在晚上创建的ID的IDS大于同一天早上创建的ID。 
候选人：ID只包含数值吗？ 
采访者：是的，这是正确的。 
候选人：ID长度要求是什么？ 
采访者：ID应该适合64位。 
候选人：系统的规模是什么？ 
采访者：系统应该能够每秒生成10,000个ID

以上是您可以提出面试官的一些示例问题。 了解要求并澄清歧义非常重要。 对于此面试问题，要求列出如下:
- ID必须是唯一的。 
- ID仅是数值。
- IDS适合64位。 
- IDS按日期订购。
- 能够生成每秒10,000多个唯一ID 



### 第2步 - 提出高水平设计并获得买入 
我们可以有多个选择来在分布式系统中生成唯一ID。 我们考虑的选项是:
- 多主复制
- 普遍唯一标识符（UUID）
- ticket服务器 
- Twitter雪花算法

让我们看看它们每一项如何工作，以及每个选项的利弊。

#### 多主副本

如图7-2所示，第一个方法是多主副本
![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-7/7-2.png)

图7-2

此方法使用数据库'auto_increment功能。 我们不是将下一个ID增加1，而是通过k增加它，其中k是使用中的数据库服务器的数量。 如图7-2所示，要生成的下一个ID等于同一服务器加2.中的前一个ID。这解决了一些可伸缩性问题，因为ID可以使用数据库服务器的数量缩放。 但是，这一方法有一些主要的缺点：
- 难以使用多个数据中心缩放。
> 一个数据中心增加一台mysql，另一处的数据中心也要同步。
- 这钟ID在多个服务器上没有时间随时间上升。
- 添加或删除服务器时，它不会很好地扩展
> 如果一台mysql增加删除，都会导致webserver 去哪台mysqlserver去拿数据，甚至出现部分数据无法访问。

#### uuid

UUID是获取唯一ID的另一种简单的方法。 UUID是一个128位数字，用于识别计算机系统中的信息。 UUID具有非常低的冲突概率。 从维基百科引用，“在每秒每秒生成10亿个uuids100年后，建立单一重复达到50％的概率将达到50％”[1]。 这是UUID：09C93E62-50B4-468D-BF8A-C07E1040BFB2的示例。 可以独立生成UUID，而无需在服务器之间协调。 图7-3显示了UUIDS设计 

这是UUID：09C93E62-50B4-468D-BF8A-C07E1040BFB2的示例。 可以独立生成UUID，而无需在服务器之间协调。 图7-3显示了UUIDS设计 
![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-7/7-3.png)
图7-3

在这种设计中，每个Web服务器都包含一个ID生成器，并且Web服务器负责独立生成ID 
好处：
- 生成uuid很简单。 不需要服务器之间的协调，因此不会有任何同步问题 
- 系统易于扩展，因为每个Web服务器负责生成它们消耗的ID。 ID生成器可以用Web服务器轻松扩展 。
缺点:
  
- ID的长度为128位，但我们的要求为64位
- ID不会随着时间增加 
- ID可能是非数字的

#### Ticket服务器
Ticket服务器是生成唯一ID的另一个有趣方法。 闪烁开发的机票服务器以生成分布式主键[2]。 值得一提的是系统如何运作

![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-7/7-4.png)
图7-4
该想法是在单个数据库服务器（票务服务器）中使用中心化AUTO_INCREMENT功能。 要了解更多关于此信息，请参阅Flicker的工程博客文章[2]
有点:
- 数字型ID
- 这个非常容易实现，这种实现方式适合中等规模的应用
缺点：
- 单点故障。 单个票证服务器意味着如果票务服务不可用，则所有依赖于它的系统将面临问题。 为避免单点故障，我们可以设置多个票证服务器。 但是，这将引入新的挑战，如数据同步 

#### Twitter算法
上面提到的方法为我们提供了一些关于不同ID生成系统的工作的想法。 但是，他们都没有满足我们的具体要求; 因此，我们需要另一种方法。 Twitter的唯一ID生成系统称为“雪花”[3]是鼓舞人心的，可以满足我们的要求。
分而治之是我们的朋友。 我们将ID分为不同的部分，而不是直接生成ID。 图7-5显示了64位ID的布局。

下面解释每个部分：
- 符号位：1位。 它永远是0.这是为了将来的用途保留。 它可能被用来区分签名和无符号的数字
- 时间戳：41位。 自纪元或自定义纪元以来的毫秒数。 我们使用Twitter雪花默认纪元1288834974657，相当于UTC 2010年11月4日，01：42：54。
- Datacenter ID：5位，给我们2 ^ 5 = 32个数据中心
- 机器ID：5位，这使我们每个数据中心有2 ^ 5 = 32台机器 
- 序列号：12位。 对于在该机器/流程上生成的每个ID，序列号递增1.数字重置为0毫秒 

## 精细化设计

在高水平设计中，我们讨论了在分布式系统中设计唯一ID生成器的各种选项。 我们解决了一种基于Twitter雪花ID生成器的方法。 让我们深入设计。 为了刷新我们的记忆，设计图在下面重新展示。

![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-7/7-5.png)
图7-5
通常修复系统运行后， 在启动时选择数据中心ID和机器ID。 数据中心ID和机器ID中的任何更改都需要仔细审查，因为这些值的意外更改可能导致ID冲突。 当ID生成器正在运行时生成时间戳和序列号。

### Timestamp
最重要的41位构成时间戳部分。 随着时间戳随着时间的推移而增长，IDS可按时间排序。 图7-7示出了二进制表示如何将二进制表示转换为UTC的示例。 您还可以使用类似的方法将UTC转换回二进制表示 


### 序列号
可以在41位表示的最大时间戳是2 ^ 41-1 = 2199023255551毫秒（MS），它给我们：〜69岁=序列号是12位，给我们2 ^ 12 = 4096组合。 除非在同一服务器上的毫秒内生成多个ID，否则此字段为0。 在理论上，机器可以支持每毫秒的最多4096个新ID 2199023255551 MS / 1000秒/ 365天/ 24小时/ 3600秒。 这意味着ID生成器将工作为69年，并在今天的日期接近自定义时分延迟溢出时间。 69年后，我们需要一个新的时代时间或采用其他技术来迁移ID

### 总结
在本章中，我们讨论了设计唯一ID生成器的不同方法：多主复制，UUID，票务服务器和Twitter Snopflake唯一ID生成器。 我们在雪花上定居，因为它支持我们所有的用例，并且在分布式环境中可扩展 

如果在面试结束时有额外的时间，这里有一些额外的谈话要点:
- 时钟同步。 在我们的设计中，我们假设ID生成服务器具有相同的时钟。 当服务器在多个核上运行时，此假设可能不是真的。 多机器场景中存在相同的挑战。 时钟同步的解决方案超出了本书的范围; 但是，重要的是要了解问题存在。 网络时间协议是此问题最流行的解决方案。 对于有感兴趣的读者，请参阅参考资料[4]
- 部分bit位调整。  例如，序列号更少但时间戳位更多对于低并发性和长期应用是有效的。
- 高可用性。 由于ID生成器是一个关键任务系统，因此必须高度可用。

恭喜你坚持到最后！ 现在给自己比个耶！ good job！

### 参考资料
- [1]普遍唯一的标识符:https://en.wikipedia.org/wiki/Universally_unique_identifier
- [2]售票服务器：廉价的分布式唯一主键：https://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the- cheap/
- [3]宣布雪花:https://blog.twitter.com/engineering/en_us/a/2010/announcing- snowflake.html
- [4]网络时间协议: https://en.wikipedia.org/wiki/Network_Time_Protocol