## 第12章设计一个聊天系统

在本章中，我们探索聊天系统的设计。 几乎每个人都使用聊天应用程序。 图12-1显示了市场中最受欢迎的应用程序 
<div align=center>

![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-12/12-1.png)

图 12-1

</div>

聊天应用对不同的人表现出不同的功能。 弄清楚确切的需求是非常重要的。 例如，当面试官想要一个一对一聊天时，但是你却想设计一个专注于群聊的系统。 探索功能要求非常重要。

### 第1步
达成一致聊天应用程序的设计至关重要。 在市场上，有一对一的聊天应用程序，如Facebook Messenger，WeChat和Whatsapp，Office聊天应用程序专注于小组聊天，如松弛，或游戏聊天应用程序，如discord，专注于大型群体交互和低音 聊天延迟。

当她要求您设计聊天系统时，第一套澄清问题应钉在于面试官的内容。 至少，弄清楚你是否应该专注于一对一的聊天或群聊的应用程序。 您可能会问的一些问题如下。

候选人：我们设计什么样的聊天应用程序？ 1或基于1组？ 
面试官：它应该支持1 on 1和群组聊天。 
候选人：这是一个移动应用程序吗？ 还是一个web应用程序？ 或两者？
面试官：两者。 
候选人：这个应用程序的规模是什么？ 启动应用程序或大规模规模？
面试官：它应该支持5000万天的活跃用户（DAU）。 
候选人：对于团体聊天，小组成员限制是什么？
面试官：最多100人
候选人：什么功能对聊天应用很重要？ 它可以支持附件吗？
面试官：1在1聊天，小组聊天，在线指示器。 系统仅支持短信。 
候选人：有消息大小限制吗？
面试官：是的，文本长度应少于100,000个字符。 
候选人：需要端到端加密吗？
面试官：不需要现在，但如果时间允许，我们将讨论。 
候选人：我们储存聊天历史多长时间？
面试官：永远 

在本章中，我们专注于设计像Facebook Messenger这样的聊天应用程序，重点是以下功能:
- 与低交货延迟的一对一聊天
- 小型群聊（最多100人）
- 在线状态
- 多个设备支持。 
- 可以同时登录多个帐户的同一帐户。 
- 推送通知。

对设计规模达成一致意见也很重要。 我们将设计一个支持5000万DAU的系统。

### 第2步-提出高水品设计并获得认可

为了开发高质量的设计，我们应该有一个基本了解客户和服务器如何沟通。 在聊天系统中，客户端可以是移动应用程序或Web应用程序。 客户端不会直接互相沟通。 相反，每个客户端连接到聊天服务，支持上面提到的所有功能。 让我们专注于基本操作。 聊天服务必须支持以下功能
- 从其他客户端接收消息。 
- 为每条消息查找合适的收件人并将邮件中继到收件人。 
- 如果收件人未在线，服务器上先的该收件人的消息，直到她在线再发送给他。

图12-2显示了客户端（发件人和接收者）与聊天服务之间的关系。
<div align=center>

![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-12/12-2.png)

图 12-2

</div>

当客户打算开始聊天时，它使用一个或多个网络协议连接聊天服务。 对于聊天服务，网络协议的选择很重要。 让我们与面试官讨论这一点。

请求是由客户端发起的，对于大多数客户端/服务器应用程序。 这对于聊天应用程序的发送方也是如此。 在图12-2中，当发件人通过聊天服务向接收者发送消息时，它使用时间测试的HTTP协议，这是最常见的Web协议。 在这种情况下，客户端与聊天服务打开HTTP连接并发送消息，通知服务将消息发送到接收器。 保持活力是有效的，因为保持活动标题允许客户端与聊天服务保持持久连接。 它还减少了TCP握手的数量。 HTTP是发件人方面的一个精细选项，以及许多流行的聊天应用程序，如Facebook [1]最初使用HTTP发送消息。

#### 轮询 

如图12-3所示，轮询是客户端定期询问服务器，如果有可用的消息，则为服务器。 根据轮询频率，轮询可能是昂贵的。 它可以消耗珍贵的服务器资源来回答一个问题，其中大部分问题都是没有意义的。
<div align=center>

![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-12/12-3.png)

图 12-3

</div>

#### WebSocket
WebSocket是从服务器到客户端发送异步更新的最常见解决方案。 图12-5显示了它的工作原理。
<div align=center>

![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-12/12-5.png)

图 12-5

</div>

WebSocket连接由客户端启动。 这是双向和持久的。 它将其生命作为HTTP连接启动，可以通过一些定义的握手“升级”到WebSocket连接。 通过此持久连接，服务器可以向客户端发送更新。 即使防火墙到位，WebSocket连接通常也可以工作。 这是因为它们使用了HTTP / HTTPS连接使用的端口80或443。

早些时候我们说，在发件人侧HTTP是一种极好的协议，但由于WebSocket是双向的，因此没有强大的技术原因不使用它来发送。 图12-6显示了WebSockets（WS）如何用于发件人和接收方面。

<div align=center>

![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-12/12-6.png)

图 12-6

</div>

通过使用WebSocket进行发送和接收，它简化了设计并使客户端和服务器的实现更加简单。 由于WebSocket连接是持久的，所以有效的连接管理在服务器端是至关重要的。

### 高水平的设计

刚才我们刚才提到WebSocket被选为客户端和服务器之间的主要通信协议，以实现其双向通信，重要的是要注意其他所有内容都不必是WebSocket。 实际上，聊天应用程序的大多数功能（注册，登录，用户配置文件等）可以在HTTP上使用传统的请求/响应方法。 让我们钻取一下并查看系统的高级组件。

如图12-7所示，聊天系统分为三大类：无状态服务，有状态服务和第三方集成。

<div align=center>

![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-12/12-7.png)

图 12-7

</div>

#### 无状态服务
无状态服务是传统的面向公众的请求/响应服务，用于管理登录，注册，用户配置文件等。这些是许多网站和应用程序的常用功能。 无状态服务位于负载均衡器的后面，负载均衡器的工作是根据请求路径将请求路由到正确的服务。 这些服务可以是单片服务，也可以是单个微服务。 我们不需要自己构建许多无状态服务，因为市场上有可以轻松集成的服务。 我们将在深入探讨中讨论的一项服务是服务发现。 它的主要工作是为客户端提供客户端可以连接到的聊天服务器的DNS主机名列表。

#### 有状态服务
唯一的有状态服务是聊天服务。 服务是有状态的，因为每个客户端维护到聊天服务器的持久网络连接。 在此服务中，只要服务器仍然可用，客户端通常不会切换到另一个聊天服务器。 服务发现与聊天服务密切坐标以避免服务器过载。 我们将深入设计这一块。

#### 第三方整合
对于聊天应用程序，推送通知是最重要的第三方集成。 即使应用程序未运行，新消息已到达，它是一种通知用户的方法。 推送通知的正常集成至关重要。 有关更多信息，请参阅第10章设计通知系统。

#### 可扩展性

在小规模上，上面列出的所有服务都可以适用于一个服务器。 即使在我们设计的范围内，它就理论上可以在一个现代云服务器中符合所有用户连接。 服务器可以处理的并发连接的数量很可能是限制因素。 在我们的场景中，在1M并发用户，假设每个用户连接需要服务器上的10K内存（这是一个非常粗略的数字，并且非常依赖于语言选择），它只需要大约10GB的内存来保存一个连接所有连接 盒子。

如果我们提出了一台服务器的一切都适合的设计，这可能会在面试官的思想中提高一个大红旗。 没有技术科学家将在单个服务器中设计这样的比例。 由于许多因素，单服务器设计是一个交易破碎机。 单点失败是其中最大的。

但是，从单一服务器设计开始是完全正常的。 只需确保面试官知道这是一个起点。 将我们在一起提到的一切，图12-8显示了调整后的高级设计。

<div align=center>

![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-12/12-8.png)

图12-8

</div>

在图12-8中，客户端将持久的WebSocket连接与聊天服务器维持以进行实时消息。

- 聊天服务器促进消息发送/接收。
- 呈现服务器管理在线/脱机状态。
- API服务器处理包含用户登录，注册，更改配置文件等的所有内容。
- 通知服务器发送推送通知。 
- 最后，键值存储用于存储聊天历史记录。 当脱机用户在线时，她会看到她之前的所有聊天记录。

#### 存储

在这一点上，我们准备好了服务器，服务运行和第三方集成完成。 深下技术堆栈是数据层。 数据层通常需要一些努力来获得正确的。 我们必须制作的一个重要决定是决定要使用的正确类型的数据库：关系数据库或NoSQL数据库？ 要做出明智的决定，我们将检查数据类型和读/写模式。

典型的聊天系统中存在两种类型的数据。 第一个是通用数据，例如用户配置文件，设置，用户朋友列表。 这些数据存储在鲁棒和可靠的关系数据库中。 复制和分片是满足可用性和可扩展性要求的常用技术。

第二个是聊天系统的独特：聊天历史数据。 了解读/写模式非常重要。

- 聊天系统的数据量是巨大的。 前一项研究[2]揭示了Facebook Messenger和WhatsApp每天处理60亿条消息。
- 频繁访问最近的聊天。 用户通常不会查找旧聊天。 
- 虽然在大多数情况下查看了非常近似的聊天记录，但用户可能会使用需要随机访问数据的功能，例如搜索，查看您的提到，跳转到特定消息等。这些情况应该由数据访问层支持。 
- 读写比率约为1：1为1次聊天应用程序 

选择支持所有使用情况的正确存储系统至关重要。 我们推荐键值存储原因如下：
- 键值存储允许易于水平缩放。
- 键值存储提供访问数据的非常低的延迟。
- 关系数据库不会处理数据的长尾部[3]。 
- 当索引生长大时，随机访问昂贵。 
- 其他经过验证可靠的聊天应用程序采用密钥值存储。 例如，Facebook Messenger和Discord都使用键值存储。 Facebook Messenger使用HBase [4]，并且Discord使用Cassandra [5]

### 数据模型
刚才，我们讨论使用键值存储作为我们的存储层。 最重要的数据是消息数据。 让我们仔细看看。

#### 1对1访问的消息表

图12-9显示了1次聊天的消息表。 主键是Message_ID，有助于决定消息序列。 我们不能依赖于CreateD_AT来决定消息序列，因为可以同时创建两条消息。

<div align=center>

![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-12/12-9.png)

图12-9

</div>

#### 组聊天的消息表 

图12-10显示了群聊的消息表。 复合主键是（channel_id，message_id）。 通道和组在这里代表相同的含义。 channel_id是分区键，因为群聊中的所有查询都在一个通道中操作 
<div align=center>

![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-12/12-10.png)

图12-10

</div>

#### 消息id
如何生成Message_ID是一个值得探索的有趣话题。 Message_ID承担确保消息顺序的责任。 要确定消息的顺序，Message_ID必须满足以下两个要求：
- ID必须是唯一的 
- ID应该按时间排序，这就意味着新行具有比旧的更高的ID。 

我们如何实现这两个保证？ 首先想到的是MySql中的“ auto_increment”关键字。 但是，NoSQL数据库通常不提供这种功能。 

第二种方法是使用像雪花一样的全局64位序列号发生器[6]。 这在“第7章：在分布式系统中设计了唯一ID生成器”中讨论。 

最终方法是使用本地序列号生成器。 本地意味着ID仅在组中唯一。 本地IDS工作的原因是维护一对一信道或组频道的消息序列就足够了。 与全局ID实现相比，这种方法更容易实现。


### 步骤3

在系统设计面试中，通常您预计将深入设计高水品中的一些组件。 对于聊天系统，服务发现，消息传递和在线/离线指标值得深入探索。

#### 服务发现 

服务发现的主要作用是根据地理位置，服务器容量等标准推荐客户的最佳聊天服务器.Apache zookeeper [7]是服务发现的流行开源解决方案。 它注册了所有可用的聊天服务器，并根据预定义的标准选择客户端的最佳聊天服务器。

图12-11显示了服务发现（Zookeeper）的工作原理。

<div align=center>

![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-12/12-11.png)

图12-11

</div>
1.用户尝试登录应用程序。 
2.负载均衡器向API服务器发送登录请求。 
3.后端验证用户后，服务发现查找用户A的最佳聊天服务器。在此示例中，选择服务器2，服务器信息返回给用户A. 
4.用户A通过WebSocket连接到聊天服务器2

#### 消息流

了解聊天系统的端到端流动是有趣的。 在本节中，我们将探讨1在1个聊天流程，跨多个设备的消息同步和组聊天流程。

##### 1在1个聊天流程

图12-12解释了当用户A向用户发送消息时会发生什么
<div align=center>

![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-12/12-12.png)

图12-12

</div>
1.用户A将聊天消息发送到聊天服务器1。
2.聊天服务器1从ID生成器获取消息ID。 
3.聊天服务器1将消息发送到消息同步队列。 
4.消息存储在键值存储中。 
5.A. 如果用户B在线，则将消息转发到聊天服务器2，其中用户B已连接。 
5.B. 如果用户B是脱机的，则从推送通知（PN）服务器发送推送通知。 
6.聊天服务器2将消息转发给用户B.用户B和聊天服务器2之间存在持久的WebSocket连接 

##### 跨多个设备的消息同步

许多用户有多个设备。 我们将解释如何在多个设备上同步消息。 图12-13显示了消息同步的示例
<div align=center>

![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-12/12-13.png)

图12-13
</div>

在图12-13中，用户A有两个设备：手机和笔记本电脑。 当用户使用手机登录聊天应用程序时，它建立了与聊天服务器1的WebSocket连接。类似地，笔记本电脑和聊天服务器之间有一个连接。

每个设备都维护一个名为cur_max_message_id的变量，它会跟踪设备上的最新消息ID。 满足以下两个条件的消息被视为新闻消息 

- 收件人ID等于当前登录的用户ID 
- 键值存储中的消息ID大于cur_max_message_id 

在每个设备上具有不同的Cur_max_Message_ID，消息同步非常轻松因为个设备都可以从KV商店获取新消息。

##### 小组聊天流程 
与一对一聊天相比，群聊的逻辑更复杂。 图12-14和12-15解释了流程

<div align=center>

![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-12/12-14.png)

图12-14
</div>

图12-14解释了当用户A在群聊中发送消息时会发生什么。 假设组中有3个成员（用户A，用户B和用户C）。 首先，来自用户A的消息被复制到每个组成员的消息同步队列：用户B和第二个用户C.您可以将消息同步队列视为收件人的收件箱。 这个设计选择对小组聊天有益，因为 
- 它简化了消息同步流量，因为每个客户端只需要检查自己的收件箱以获取新消息。
- 当组数较小时，将副本存储在每个收件人的收件箱中并不太昂贵 

微信使用类似的方法，并将一个组限制为500个成员[8]。 但是，对于具有大量用户的组，存储每个成员的消息副本是不可接受的 
<div align=center>

![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-12/12-15.png)

图12-15
</div>

#### 在线状态

在线表现指示器是许多聊天应用程序的重要特征。 通常，您可以在用户配置文件图片或用户名旁边看到绿色点。 本节介绍了场景后面发生的事情。 

在高水品设计中，存在服务器负责管理在线状态并通过WebSocket与客户端通信。 有几个流程将触发在线状态更改。 让我们检查每个人 

##### 用户登录
“服务发现”部分解释了用户登录流程。 在客户端和实时服务之间构建WebSocket连接之后，用户A的在线状态和Last_Active_At时间戳将保存在KV存储中。 在她登录后，存在指示灯显示用户在线。
<div align=center>

![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-12/12-16.png)

图12-16
</div>
##### 用户登出
当用户注销时，它会通过用户注销流程，如图12-17所示。 在线状态更改为kv存储中的脱机。 存在指示器显示用户离线。
<div align=center>

![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-12/12-17.png)

图12-17
</div>

##### 用户断开
我们都希望我们的互联网连接一致可靠。 但是，这并不总是这种情况; 因此，我们必须在我们的设计中解决这个问题。 当用户断开与Internet的连接时，客户端和服务器之间的持久连接丢失。 处理用户断开的天真的方法是将用户标记为离线，并在连接重新建立时将状态更改为在线。 然而，这种方法有一个重大缺陷。 对于用户在短时间内断开并重新连接到互联网是常见的。 例如，用户通过隧道时可以打开和关闭网络连接。 在每个断开/重新连接上更新在线状态将使存在指示器变化频繁，导致用户体验不佳

我们引入了心跳机制来解决此问题。 联机客户端会定期将心跳事件发送到状态服务器。 如果状态显示服务器在一定时间内（例如x秒钟）从客户端接收到心跳事件，则该用户被视为在线。 否则，它处于离线状态。

在图12-18中，客户端每隔5秒向服务器发送心跳事件。 发送3个心跳事件后，客户端断开连接，不会在x = 30秒内重新连接（此号码被任意选择以演示逻辑）。 在线状态已更改为脱机。

<div align=center>

![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-12/12-18.png)

图12-18
</div>

##### 好友的在线状态
用户A的朋友如何了解状态更改？ 图12-19解释了它是如何工作的。 呈现服务器使用发布 - 订阅模型，其中每个朋友对维护一个通道。 当用户A的在线状态更改时，它将事件发布到三个通道，通道A-B，A-C和A-D。 这三个通道分别由用户B，C和D订购。 因此，很容易的朋友来获取在线状态更新。 客户端和服务器之间的通信是通过实时的WebSocket
<div align=center>

![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-12/12-19.png)

图12-19
</div>

以上设计对于小用户组是有效的。 例如，WeChat使用类似的方法，因为其用户组被缩写为500.对于更大的组，信息通知所有成员关于在线状态的昂贵且耗时。 假设一个团体有100,000名成员。 每个状态更改都会生成100,000个事件。 为了解决性能瓶颈，可能的解决方案仅在用户输入组或手动刷新朋友列表时才能获取在线状态

### 总结

在本章中，我们介绍了一个聊天系统架构，支持1到1聊天和小组聊天。 WebSocket用于客户端和服务器之间的实时通信。 聊天系统包含以下组件：用于实时消息的聊天服务器，用于管理在线状态的呈现服务器，推送通知服务器，用于发送推送通知，聊天记录持久性和其他功能的API服务器的键值存储器。

如果您在面试结束时有额外的时间，这里有额外的谈话要点:
- 扩展聊天应用以支持媒体文件，如照片和视频。 媒体文件明显大于大小的文本。 压缩，云存储和缩略图是有趣的话题讨论。
- 端到端加密。 Whatsapp支持消息的端到端加密。 只有发件人和收件人可以阅读邮件。 有兴趣的读者应参考参考资料中的文章[9]
- 在客户端缓存消息可有效减少客户端和服务器之间的数据传输。
- 提高负载时间。 Slack建立了一个地理上分布式网络，以缓存用户的数据，通道等，以获得更好的负载时间[10]
- 错误处理
  - 聊天服务器错误。 可能存在数十万，甚至更持久的连接到聊天服务器。 如果聊天服务器脱机，服务发现（ZooKeeper）将为客户端提供新的聊天服务器，以建立新的连接。
    
  - 消息重发机制。 重试和排队是重新发送消息的常用技术 

恭喜迈出了这一点！ 现在让自己放在背上。 做得好。