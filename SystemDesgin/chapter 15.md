## 设计一个Google Driver

近年来，云存储服务如Google Drive，Dropbox，Microsoft Onedrive和Apple Icloud等非常受欢迎。 在本章中，您被要求设计Google Drive 

让我们花点时间才能在开始设计之前了解谷歌驱动器。 Google Drive是一个文件存储和同步服务，可帮助您存储云中的文档，照片，视频和其他文件。 您可以从任何计算机，智能手机和平板电脑访问您的文件。 您可以轻松与朋友，家庭和同事共享这些文件[1]。 图15-1和15-2分别显示了浏览器和移动应用程序的Google Drive 


![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-15/15-1.png)

图 15-1

![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-15/15-2.png)

图 15-2

### 理解问题并且创建设计范围

设计Google Drive是一个大项目，因此请提出问题缩小范围很重要。

候选人：最重要的功能是什么？ 

面试官：上传和下载文件，文件同步和通知。 

候选人：这是一个移动应用程序，一个Web应用程序还是两者？ 

面试官：两者。 

候选人：支持的文件格式是什么？ 

面试官：任何文件类型。 

候选人：需要加密文件吗？ 

面试官：是的，必须加密存储中的文件。 

候选人：有文件大小限制吗？ 

面试官：是的，文件必须为10 GB或更小。 

候选人：产品有多少用户？ 

面试官：10M DAU 

在本章中，我们专注于以下功能:

- 添加文件。 添加文件的最简单方法是将文件拖放到Google Drive中。
- 下载文件。
- 跨多个设备同步文件。 当文件添加到一个设备时，它会自动同步到其他设备。
- 请参阅文件修订（See file revisions。
- 与您的朋友，家庭和同事分享文件。
- 在编辑，删除或与您共享文件时发送通知。

本章中未讨论的功能包括:

- Google Doc编辑和协作。 Google文档允许多个人同时编辑相同的文档。 这是我们的设计范围。

除了澄清要求外，了解非功能性要求非常重要:

- 可靠性。 可靠性对于存储系统非常重要。 数据丢失是不可接受的。
- 快速同步速度。 如果文件同步需要太多时间，用户将变得不耐烦并放弃产品。
- 带宽使用。 如果产品需要大量不必要的网络带宽，用户将不满意，特别是当它们在移动数据使用时。
- 可扩展性。 系统应该能够处理大量流量。
- 高可用性。 当某些服务器脱机时，用户仍然可以使用该系统，减慢，或具有意外的网络错误。

#### 信封估计 

- 假设申请有5000万签约用户和1000万DAU
- 用户获得10 GB的可用空间 
- 假设用户每天上传2个文件。 平均文件大小为500 kB
- 1：1读写写入比率 
- 分配的总空间：5000万* 10 GB = 500 PETABYTE 
- 上传API的QPS：1000万* 2上传/ 24小时/ 3600秒=〜240
- 峰值QPS = QPS * 2 = 480

### 提出高水平设计并获得认可

我们将使用略微不同的方法而不是从一开始就显示高级设计图。 我们将从简单的东西开始：在单个服务器中构建所有内容。 然后，逐渐扩大它以支持数百万用户。 通过执行此练习，它将刷新您的记忆，了解书中涵盖的一些重要主题 

让我们从下面列出的单个服务器设置开始:

- 用于上传和下载文件的Web服务器。
- 一个数据库，以跟踪元数据，如用户数据，登录信息，文件信息等。
- 存储文件的存储系统。 我们分配了1TB的存储空间来存储文件。

我们花了几个小时设置Apache Web服务器，MySQL数据库和一个名为Drive /作为根目录的目录来存储上传的文件。 在驱动器/目录下，有一个目录列表，称为名称空间。 每个命名空间包含该用户的所有上载文件。 服务器上的文件名保持与原始文件名相同。 通过加入命名空间和相对路径，可以唯一地识别每个文件或文件夹。

图15-3显示了/驱动器目录在左侧的左侧看起来的示例及其扩展视图。


![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-15/15-3.png)
图15-3

#### APIS
API是什么样的？ 我们主要需要3 API：上传文件，下载文件，获取文件修订。

1. 将文件上传到Google Drive 

支持两种类型的上传:

- 简单上传。 文件大小小时使用此上载类型。
- 更糟糕的上传。 当文件大小大而使用此上载类型，网络中断有很大的机会。

这是恢复上传API的一个例子:
https://api.example.com/files/upload?uploadType=resumable

参数:
- uploadType =可恢复
- 数据：要上载的本地文件

通过以下3个步骤[24]可恢复上传:
- 发送初始请求以检索可恢复的URL 
- 上传数据和监视上传状态
- 如果上传受到干扰，请恢复上传

2. 从Google Drive下载文件 

Example API: https://api.example.com/files/download

参数:
- 路径:下载路径参数

参数例子:
```json
{ 
  "path": "/recipes/soup/best_soup.txt"
}
```

3. 获取文件修订
   示例API：https://api.example.com/files/list_revisions 
参数
   
- 路径: 你想获得文件修订历史的文件路径。
- 限制: 返回最大数量的修订。


参数例子:
```json
{ 
  "path": "/recipes/soup/best_soup.txt",
  "limit": 20
}
```

所有API都需要用户身份验证并使用HTTPS。 安全套接字层（SSL）保护客户端和后端服务器之间的数据传输 

#### 远离单一服务器 

随着更多文件上传，最终您可以获得空间完整警报，如图15-4所示 


![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-15/15-4.png)

图15-4

仅剩10 MB的存储空间！ 这是紧急情况，因为用户无法再上传文件。 我想到的第一个解决方案是数据分片，因此将其存储在多个存储服务器上。 图15-5显示了一个基于user_id的分片示例。

![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-15/15-5.png)

图15-5

您需要花一整夜的时间来设置数据库分片并对其进行密切监视。 一切再次顺利进行。 您已经准备停止设计，但是您仍然担心在存储服务器中断的情况下潜在的数据丢失。 您四处询问，您的后端专家朋友Frank告诉您，许多领先的公司（例如Netflix和Airbnb）都使用Amazon S3进行存储。 “ Amazon Simple Storage Service（Amazon S3）是一种对象存储服务，可提供行业领先的可扩展性，数据可用性，安全性和性能” [3]。 您决定进行一些研究，看是否合适。

经过大量阅读后，您对S3存储系统有了很好的了解，并决定将文件存储在S3中。 Amazon S3支持同区域和跨区域复制。 区域是Amazon Web Services（AWS）拥有数据中心的地理区域。 如图15-6所示，可以在同一区域（左侧）和跨区域（右侧）上复制数据。 冗余文件存储在多个区域中，以防止数据丢失并确保可用性。 存储桶就像文件系统中的文件夹。

![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-15/15-6.png)

图15-6

将文件存储在s3中，您可以终于睡个好觉，而不担心数据丢失。 为了停止未来发生类似的问题，您决定对您可以改进的区域进行进一步研究。 以下是您找到的几个区域:
- Load Balancer：添加负载均衡器以分发网络流量。 负载均衡器确保均匀分布式流量，如果Web服务器衰减，则会重新分配流量 
- Web服务器：添加负载均衡器后，可以轻松地添加/删除更多的Web服务器，具体取决于流量负载 
- 元数据数据库：将数据库移出服务器，以避免单点故障。 同时，设置数据复制和分片以满足可用性和可伸缩性要求 
- 文件存储：Amazon S3用于文件存储。 为确保可用性和耐用性，文件在两个单独的地理区域中复制 

在应用上述改进后，您已成功地解耦了Web服务器，元数据数据库和从单个服务器的文件存储。 更新的设计如图15-7所示
![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-15/15-7.png)
图15-7

### 同步冲突
对于像Google Drive这样的大存储系统，同步冲突不时发生。 当两个用户同时修改相同的文件或文件夹时，会发生冲突。 我们如何解决冲突？ 以下是我们的策略：获取的第一个版本，以及后来处理的版本接收到冲突。 图15-8显示了同步冲突的示例
![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-15/15-8.png)
图15-8

在图15-8中，用户1和用户2尝试同时更新相同的文件，但用户首先由我们的系统处理用户1的文件。 用户1的更新操作通过，但是，用户2获得同步冲突。 我们如何解决用户2的冲突？ 我们的系统呈现了同一文件的两个副本：用户2的本地副本和来自服务器的最新版本（图15-9）。 
用户2可以选择合并两个文件或使用另一个版本覆盖一个版本 

当多个用户正在编辑相同的文档，但保持文档同步是具有挑战性的。 感兴趣的读者应参考参考资料[4] [5 

### 宏观设计

图15-10说明了所提出的高级设计。 让我们检查系统的每个组件

**用户**：用户通过浏览器或移动应用程序使用该应用程序。

**块服务器**：块服务器将块上传到云存储。 块存储，称为块级存储，是一种在基于云的环境中存储数据文件的技术。 可以将文件分成多个块，每个块具有唯一的散列值，存储在我们的元数据数据库中。 每个块被视为独立对象并存储在我们的存储系统中（S3）。 要重建文件，块以特定顺序加入。 至于块大小，我们使用Dropbox作为参考：将块的最大大小设置为4MB [6 

**云存储**：文件分为较小的块并存储在云存储中。

**冷库**：冷库是一个用于存储非活动数据的计算机系统，意味着长时间无法访问文件。

**负载平衡**：负载平衡器均匀分布API服务器之间的请求。

**API服务器**：这些服务器负责上传流程以外的几乎所有事务。 API服务器用于用户身份验证，管理用户配置文件，更新文件元数据等 

**元数据数据库**：它存储用户，文件，块，版本等元数据请注意，文件存储在云中，元数据数据库仅包含元数据。

**元数据缓存**：缓存了一些元数据以便快速检索。

**通知服务**：它是一个发布者/订阅者系统，允许将数据从通知服务传输到客户端，因为某些事件发生。 在我们的具体情况下，通知服务在添加/编辑/删除其他地方时通知相关客户端，以便他们可以提取最新更改。

## 第3步 - 深度设计
在本节中，我们将仔细查看以下内容：块服务器，元数据数据库，上传流，下载流程，通知服务，保存存储空间和故障处理。
### 块服务器
对于定期更新的大文件，每次更新都发送整个文件会占用大量带宽。 提出了两种优化措施以最大程度地减少正在传输的网络流量：
- delta sync。 修改文件时，仅使用同步算法同步修改块而不是整个文件[7] [8]
- 压缩。 在块上应用压缩可以显着降低数据大小。 因此，根据文件类型使用压缩算法压缩块。 例如，GZIP和BZIP2用于压缩文本文件。 需要不同的压缩算法来压缩图像和视频。

在我们的系统中，块服务器为上传文件进行繁重的举重工作。 阻止服务器通过将文件拆分为块，压缩每个块并加密它们来处理从客户端传递的文件。 而不是将整个文件上传到存储系统，只传输修改后的块。

图15-11显示了块服务器在添加新文件时如何运行。
![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-15/15-11.png)

- 文件拆分为较小的块。
- 使用压缩算法压缩每个块。
- 为确保安全性，在将每个块发送到云存储之前，每个块都已加密 
- 块上传到云存储。

图15-12说明了Delta Sync，意思只有修改的块被传送到云存储。 突出显示的块“块2”和“块5”表示已更改的块。 使用Delta Sync，仅将这两个块上载到云存储器。
![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-15/15-12.png)

块服务器允许我们通过提供Delta同步和压缩来节省网络流量 

### 高一致性要求 
- 缓存副本中的数据和主站是一致的。
- 当数据库写入数据时使对应的缓存无效，以确保缓存和数据库保持相同的值。

在关系数据库中实现强的一致性很容易，因为它保持ACID（原子性，一致性，隔离，耐久性）属性[9]。 但是，NoSQL数据库默认情况下不支持ACID属性。 ACID必须以编程方式掺入同步逻辑。 在我们的设计中，我们选择关系数据库，因为ACID本地支持的。

### 元数据数据库 

图15-13显示了数据库模式设计。 请注意，这是一个高度简化的版本，因为它只包含最重要的表和有趣的字段。
![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-15/15-13.png)

**用户：** 用户表包含有关用户的基本信息，例如用户名，电子邮件，配置文件照片等。
**设备：** 设备表存储设备信息。 push_id用于发送和接收移动推送通知。 请注意，用户可以拥有多个设备
**命名空间**：命名空间是用户的根目录。
**文件：** 文件表存储与最新文件有关的所有内容。
**file_version:** 它存储文件的版本历史记录。 现有行是只读以保持文件修订历史的完整性。
**块:** 它存储与文件块相关的一切。 可以通过以正确的顺序加入所有块来重建任何版本的文件。

### 上传流程
让我们讨论客户端上传文件时会发生什么。 为了更好地了解流程，我们绘制序列图，如图15-14所示
![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-15/15-14.png)
- 添加文件元数据
   - 客户端1发送请求添加新文件的元数据。
   - 将新文件元数据存储在元数据DB中，并将文件上传状态更改为“待处理”。
   - 通知通知服务正在添加新文件。
   - 通知服务通知相关的客户端（客户端2）正在上载文件。
- 将文件上传到云存储
  - 客户端1将文件的内容上传到块服务器。
  - 块服务器将文件块块，压缩，加密块，并将其上传到云存储。
  - 上传文件后，云存储触发上传完成回调。 该请求将发送到API服务器。
  - 文件状态更改为Metadata DB中的“上载”。
  - 通知通知服务文件状态已更改为“上传”。
  - 通知服务通知相关的客户端（客户端2）文件已完全上传。

编辑文件时，流程类似，因此我们将不再重复。

### 下载流程
在其他地方添加或编辑文件时触发下载流程。 客户如何知道另一个客户端是否添加或编辑文件？ 客户可以知道有两种方式:
- 如果客户端A在线，而另一个客户端更改文件，则通知服务将通知客户端A在某处进行更改，以便您需要提取最新数据。
- 如果客户端A离线，而另一个客户端更改文件，则数据将保存到缓存中。 当离线客户端再次在线时，它会拉取最新更改。 

一旦客户端了解文件，它首先通过API服务器请求元数据，然后下载块以构建文件。 图15-15显示了详细的流量。 注意，由于空间约束，才能在图中显示最重要的组件：

![img.png](/Users/rocky/study/github/SystemDesign/image/chapter-15/15-15.png)
1. 通知服务通知客户端2文件已在其他位置更改
2. 一旦客户端2知道可用的新更新，它会发送要获取元数据的请求 
3. API服务器调用元数据DB以获取更改的元数据 
4. 元数据返回到API服务器 
5. 客户端2获取元数据 
6. 一旦客户端收到元数据，它就会向块服务器发送要下载块的请求。
7. 块服务器首先从云存储下载块。
8. 云存储将块返回给块服务器。
9. 客户端2下载所有新块以重建文件。

### 通知服务 

为了保持文件的一致性，需要将在本地执行的文件的任何突变通知其他客户端，以减少冲突。 通知服务旨在实现此目的。 在高层，通知服务允许事件发生时将数据传输到客户端。 这里有一些选择：
- 长轮询。 Dropbox使用长轮询[10 
- WebSocket。 WebSocket在客户端和服务器之间提供了持久的连接。 双向通讯。 

即使两个选项都很好地工作，我们选择了长轮询，因为以下两个原因 
- 通知服务的通信不是双向的。 服务器将有关文件更改的信息发送给客户端，但不反之亦然。
- WebSocket非常适合实时双向通信，例如聊天应用程序。 为了Google云端硬盘，通知发送很少，没有突发数据。

随着长的轮询，每个客户都建立了与通知服务的长轮询连接。 如果检测到对文件的更改，则客户端将关闭长轮询连接。 关闭连接意味着客户端必须连接到元数据服务器以下载最新更改。 收到响应或达到连接超时后，客户端立即发送新请求以保持连接打开。

### 保存存储空间

为了支持文件版本历史并确保可靠性，多个版本的相同文件跨多个数据中心存储。 可以使用所有文件修订的频繁备份快速填充存储空间。 提出了三种技术来降低储存成本：
- 消除重复数据块。 消除帐户级别的冗余块是节省空间的简单方法。 如果它们具有相同的哈希值，则两个块是相同的 
- 采用智能数据备份策略。 可以应用两种优化策略：
  - 设置限制：我们可以为存储的版本数设置限制。 如果达到限制，则最旧的版本将被替换为新版本。
  - 仅保留有价值的版本：可能会经常编辑某些文件。 例如，保存大量修改的文档的每个编辑版本可能意味着文件在短时间内保存超过1000次。 为避免不必要的副本，我们可以限制已保存版本的数量。 我们为最近的版本提供更多重量。 实验有助于弄清楚要保存的最佳版本 
- 将不经常使用的数据移动到冷存储中。 冷数据是数月或数年未激活的数据。 像Amazon S3冰川[11]这样的冷藏库比S3便宜得多。

## 故障处理 

故障可能发生在大规模系统中，我们必须采用设计策略来解决这些故障。 您的面试官可能有兴趣听取如何处理以下系统故障
- 负载均衡器失败：如果负载均衡器失败，则辅助将变为活动并拾取流量。 负载平衡器通常使用心跳相互监视，在负载均衡器之间发送的周期性信号。 如果没有一段时间，负载平衡器被认为是失败的。
- 块服务器故障：如果块服务器发生故障，则其他服务器拾取未完成或未决的作业。
- 云存储失败：S3存储桶在不同区域中多次复制。 如果在一个区域中不可用文件，则可以从不同的区域获取它们。
- API服务器故障：它是一个无状态服务。 如果API服务器失败，则通过负载均衡器将流量重定向到其他API服务器。
- 元数据缓存失败：元数据缓存服务器被复制多次。 如果一个节点发生故障，您仍然可以访问其他节点以获取数据。 我们将启动一台新的缓存服务器来替换发生故障的服务器。
- 元数据数据库故障 
 - 主节点挂掉: 如果主节点挂掉，将在从节点中选举出一主节点，再重新另起一个从节点。
 - 从节点挂掉: 如果从设备挂掉，您可以使用另一个从站进行读取操作，并将另一个数据库服务器替换失败。 
- 通知服务失败：每个在线用户都会与通知服务器保持长路的轮询。 因此，每个通知服务器都与许多用户连接。 根据2012年的Dropbox谈话[6]，每台机器开放超过100万个连接。 如果服务器衰减，则丢失所有长轮询连接，因此客户端必须重新连接到其他服务器。 尽管一台服务器可以保持许多打开连接，但它也无法立即重新连接所有丢失的连接。 与所有丢失的客户重新连接是一个相对缓慢的过程。
- 离线备份队列失败：队列已多次复制。 如果一个队列失败，则队列的消费者可能需要重新订阅备份队列。 

# 总结
在本章中，我们提出了一种支持Google云端硬盘的系统设计。 强一致性，低网络带宽和快速同步的结合使设计变得有趣。 我们的设计包含两个流程：管理文件元数据和文件同步。 通知服务是系统的另一个重要组件。 它使用长时间轮询来使客户端保持文件更新的最新状态。

就像任何系统设计面试问题一样，没有完美的解决方案。 每个公司都有其独特的约束，您必须设计一个适合这些约束的系统。 了解您的设计和技术选择的权衡很重要。 如果还剩几分钟，您可以谈谈不同的设计选择。


翻译结果
例如，我们可以直接将文件上传到来自客户端的云存储而不是通过块服务器。 这种方法的优势在于它使文件上传更快，因为只需要将文件传输一次到云存储。 在我们的设计中，文件首先传输到块服务器，然后转到云存储。 但是，新方法有一些缺点。
- 首先，必须在不同的平台上实现相同的块，压缩和加密逻辑（iOS，Android，Web）。 这是容易出错的，需要很多工程努力。 在我们的设计中，所有这些逻辑都在集中的位置实现：块服务器 
- 其次，由于客户端可以轻松被攻击或操纵，在客户端的加密逻辑实现并不理想。

系统的另一个有趣的演变正在将在线/离线逻辑移动到单独的服务。 让我们称之为呈现服务。 通过将该存在服务移出通知服务器，可以通过其他服务轻松集成在线/脱机功能。

恭喜迈出了这一点！ 现在让自己放在背上。 做得好。